import{types as t,resolvePath as e,onSnapshot as o,getSnapshot as a,applySnapshot as n}from"mobx-state-tree";import{deepEqual as r}from"../utils/deep-equal.js";Object.assign(t);export const UndoManager=t.model("UndoManager",{history:t.array(t.frozen()),undoIdx:-1,targetPath:""}).views(t=>({get canUndo(){return t.undoIdx>0},get canRedo(){return t.undoIdx<t.history.length-1}})).actions(t=>{let d,s,i=!1,c=null,h=0,u=0;const l=()=>u>0;function g(){const t=a(d);return{pages:t.pages,width:t.width,height:t.height,custom:t.custom,audios:t.audios}}function m(t){const e=d.pages.map(t=>t.id),o=t.pages.map(t=>t.id),a=!r(e,o),s=!r(d.custom,t.custom);a?n(d.pages,t.pages):d.pages.forEach((e,o)=>{n(e,t.pages[o])}),s&&d.set({custom:t.custom}),d.setSize(t.width,t.height)}return{startTransaction(){u++},endTransaction(t){u--,t||this.requestAddState(g())},async ignore(e,o=!1,a=!1){a&&await new Promise(t=>setTimeout(t,10)),h&&t.addUndoState();let n=l();t.startTransaction();let r=u;try{await e()}catch(i){setTimeout(()=>{throw i})}const d=r!==u,s=!d;t.endTransaction(s),o||n||t.replaceState(),d||(clearTimeout(h),h=0)},async transaction(e){await t.ignore(e,!0),this.addUndoState()},requestAddState(t){c=t,h||l()||(i?i=!1:h=setTimeout(()=>{h=0,clearTimeout(h),l()||this.addUndoState()},100))},addUndoState(){if(i){return void(i=!1)}const e=t.history[t.undoIdx];!r(c,e)&&(clearTimeout(h),h=0,t.history.splice(t.undoIdx+1),t.history.push(c),t.undoIdx=t.history.length-1)},afterCreate(){if(d=e(t,".."),!d){throw new Error("Failed to find target store for UndoManager. Please provide `targetPath` property, or a `targetStore` in the environment")}s=o(d,()=>{this.requestAddState(g())}),0===t.history.length&&this.requestAddState(g())},clear(){clearTimeout(h),h=0,t.history.splice(0,t.history.length),t.undoIdx=-1,t.addUndoState(g())},beforeDestroy(){s()},undo(){h&&this.addUndoState(),t.canUndo?(t.undoIdx--,i=!0,m(t.history[t.undoIdx])):console.warn("No undo history. Please check `store.history.canUndo` before calling undo action.")},redo(){h&&this.addUndoState(),t.canRedo?(t.undoIdx++,i=!0,m(t.history[t.undoIdx])):console.warn("No redo history. Please check `store.history.canRedo` before calling redo action.")},replaceState(){t.history[t.undoIdx]=g()}}});export default UndoManager;